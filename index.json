[{"content":"Quem nunca precisou fazer buscas de CEP, e o serviço de consulta estava indisponível? Daí surge a pycep, uma biblioteca escrita em python que objetiva fazer buscas em diversos serviços de maneira totalmente assíncrona.\nNesse post quero demonstrar algumas das etapas do processo de criação da biblioteca, como a concepção da ideia e também a publicação no pypi.\nA ideia é simples, uma classe que carrega automaticamente os serviços disponíveis no diretório service como se fossem plugins, e os executa retornando os dados do serviço que responder primeiro.\nEssa abordagem permite adicionar outros serviços sem maiores complicações, bastando implementar o protocolo QueryService e colocar o arquivo da classe no diretório services. E desta forma, ele será identificado pela biblioteca e será usado em novas consultas.\nA escolha do nome ideal Pensei que o melhor nome da biblioteca fosse PyCEP, já que estamos falando de Código de Endereçamento Postal, mas o nome já estava em uso por um projeto no PYPI .\nA criação de um repositório no Github Não pretendo detalhar a criação do repositório de forma extensa, mas o repositório criado pode ser acessado em https://github.com/erickod/pycep.\nA instalação do Poetry O poetry é uma ferramenta para gerenciamento de pacotes no mundo python, que simplifica todo o processo de instalação, gerenciamento e publicação de pacotes.\nComo o projeto depende fortemente do poetry, seja para configuração de algumas ferramentas ou mesmo para controle das dependências, é importante que ele esteja instalado e configurado.\nTudo que é necessário para a instalação pode ser encontrado em https://python-poetry.org/docs/, mas vou tentar simplificar aqui.\nSe você estiver utilizando Windows, abra o power shell e execute o comando abaixo:\n(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - No entanto, se for um usuário do Linux, WSL ou do MacOS, execute este comando em um terminal:\ncurl -sSL https://install.python-poetry.org | python3 - Após a instalação, o comando poetry estará disponível para uso:\npoetry --version Iniciando o projeto com o Poetry Com o repositório criado, a primeira coisa que decidir fazer foi ir a um diretório qualquer e rodar alguns comandos no terminal.\nNo diretório escolhido, executei um simples poetry new pycep, e obtive um Created package pycep in pycep.\nAo abrir o diretório pycep criado pelo poetry, vamos notar alguns arquivos e subdiretórios:\npycep - Um diretório onde o código do projeto será criado pyproject.toml - Um arquivo que armazena desde as versões do python, as dependências de desenvolvimento e de produção e a configuração de diversas ferramentas que projeto vai utilizar README.md - Um arquivo para descrever o projeto, configurações para execução ou qualquer texto que quisermos colocar. tests - Onde os testes automatizados serão criados e executados pelo test runner. Com isso temos as seguintes linhas no pyproject.toml:\n[tool.poetry] name = \u0026#34;pycep\u0026#34; version = \u0026#34;0.0.0\u0026#34; description = \u0026#34;\u0026#34; authors = [\u0026#34;Erick Duarte \u0026lt;erickod@gmail.com\u0026gt;\u0026#34;] readme = \u0026#34;README.md\u0026#34; [tool.poetry.dependencies] python = \u0026#34;^3.11\u0026#34; [tool.poetry.group.dev.dependencies] [build-system] requires = [\u0026#34;poetry-core\u0026#34;] build-backend = \u0026#34;poetry.core.masonry.api\u0026#34; O próximo passo seria \u0026lsquo;comitar\u0026rsquo; o progresso feito até aqui, e para isso fiz o seguinte:\n$ git init $ git remote add origin https://github.com/erickod/pycep $ git pull origin main $ git branch --set-upstream-to=origin/main main $ git add . $ git commit -m \u0026#34;chore: add proetry project\u0026#34; $ git push Instalando as dependências do projeto Uma coisa é certa, o static typing pode fazer projetos terem mais qualidade, capturando erros sem que o projeto precise ser executado. Em ambientes python, existem diversas ferramentas que atingem esse objetivo, e neste caso vamos usar o mypy.\nO pytest será utilizado como test runner; O black será usado para formatação e estilo de código; Para fazer a instalação das dependências, precisamos abrir algum terminal e executar o seguinte comando em nosso diretório de trabalho:\npoetry add --group dev mypy pytest black A execução do comando acima gera mudanças no poetry.lock e no pyproject.tom, e mais uma vez \u0026lsquo;comitamos\u0026rsquo; as alterações;\ngit commit -m \u0026#34;chore: add mypy, black and pytest as dev dependencies\u0026#34; E finalmente, para que a gente possa por nossas mãos no código, falta instalar uma lib que será usada em ambiente de produção, e para isso, vamos executar num terminal:\npoetry add aiohttp A estrutura do Projeto O conceito do projeto é bem simples, teremos uma classe CEP que fará algumas operações de validação e ou transformação do cep inputado, como converter CEP em inteiros para string ou outras validações relativas ao formato do CEP.\nTeremos um protocol / ABC que servirá de contrato para cada serviço de consulta de CEP, e cada serviço implementado será armazenado no diretório services. Esse diretório será lido pelo CepQueryServiceLoader, que por sua vez será responsável por importar e carregar os serviços de consulta dinamicamente, e devolvê-los para o construtor da classe pycep.\nInstanciado com a lista de serviços disponíveis, O pycep consultará cada serviço através do método query_cep, de maneira assíncrona, e o retorno será dado pelo serviço que responder mais rápido.\nAtualmente existem 3 serviços:\nCorreios ViaCep OpenCep Os protocolos e ABCs Sendo úteis para ferramentas de checagem de tipos, usei Protocols para deixar explícito qual é a interface pública de certos objetos, dos quais gostaria de destacar os serviços de consulta\nOs protocolos de certa forma se parecem com ABCs, e se formos olhar sua hierarquia de herança, veremos que em algum ponto ela herda de ABCMeta.\nNo exemplo abaixo, podemos ver exatamente como um serviço de consulta de cep deve ser parecer. O entrypoint para a consulta de um serviço qualquer ocorre através do método query_cep, que por sua vez encapsula como o consulta ocorre.\nJá o decorator @runtime_checkable fará com que isistance(MyInstance, QuerySerivce) retorne um boolean, o que será útil em alguns momentos.\nfrom typing import Protocol, runtime_checkable from pycep.cep_data import CepData @runtime_checkable class QueryService(Protocol): async def query_cep(self, cep: str) -\u0026gt; CepData: pass Carregando os serviços de consulta No diretório pycep existe um módulo chamado service_loader. Nele, o objeto CepServicesLoader é responsável por carregar todos os módulos que estão em services. Ao carregar um módulo, chama a função construtora make, que por sua vez retornará o serviço de consulta corretamente instanciado e pronto para fazer consultas.\nimport importlib from pkgutil import walk_packages from types import ModuleType from typing import Any, Callable from pycep import services from pycep.protocols.query_service import QueryService class CepQueryServiceLoader: \u0026#34;\u0026#34;\u0026#34;Import all sub modules dinamically\u0026#34;\u0026#34;\u0026#34; def __init__( self, module: ModuleType = services, walk_packages: Callable = walk_packages ) -\u0026gt; None: self._services: list[Any] = [] self._module = module self._walk_packages = walk_packages def load(self) -\u0026gt; Any: for loader, module_name, is_pkg in self._walk_packages( self._module.__path__, self._module.__name__ + \u0026#34;.\u0026#34; ): submodule = importlib.import_module(module_name) service = submodule.make() self.__is_compatible(service) and self._services.append(service) return self._services def __is_compatible(self, module: QueryService, raises: bool = True) -\u0026gt; bool: is_compatbile = isinstance(module, QueryService) if raises and not is_compatbile: raise TypeError(f\u0026#34;{module} must implement QueryService\u0026#34;) return is_compatbile A Publicação do pacote no pypi A publicação se dá maneira bem simples, com alguns poucos passos, e envolve a execução de alguns comandos no poetry, a criação de uma conta e a criação de um token no pypi, para que o poetry possa publicar pacotes.\nCriação da API token no PYPI Configuração do Poetry para usar o token: poetry config pypi-token.pypi Criamos o build do projeto: poetry build Publicação do Pacote: publicamos o pacote executando poetry publish ","permalink":"https://erickod.dev/posts/pycep-a-criacao-e-publicacao-de-uma-lib-em-python/","summary":"\u003cp\u003eQuem nunca precisou fazer buscas de CEP, e o serviço de consulta estava indisponível? Daí surge a \u003cstrong\u003epycep\u003c/strong\u003e, uma biblioteca escrita em python que objetiva fazer buscas em diversos serviços de maneira totalmente assíncrona.\u003c/p\u003e\n\u003cp\u003eNesse post quero demonstrar algumas das etapas do processo de criação da biblioteca, como a concepção da ideia e também a publicação no \u003cstrong\u003epypi\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA ideia é simples, uma classe que carrega automaticamente os serviços disponíveis no diretório service como se fossem plugins, e os executa retornando os dados do serviço que responder primeiro.\u003c/p\u003e","title":"Pycep a Criacao E Publicacao De Uma Lib Em Python"},{"content":"","permalink":"https://erickod.dev/posts/hello-world/","summary":"","title":"Hello World"}]